__doc__ = """ Test helper functions in elastica/contact_util.py used for contact"""

import pytest
import numpy as np
from numpy.testing import assert_allclose
from elastica.utils import Tolerance
from elastica.rod import RodBase
from elastica.rigidbody import Cylinder, Sphere
from elastica.contact_utils import (
    _dot_product,
    _norm,
    _clip,
    _out_of_bounds,
    _find_min_dist,
    _aabbs_not_intersecting,
    _prune_using_aabbs_rod_cylinder,
    _prune_using_aabbs_rod_rod,
    _prune_using_aabbs_rod_sphere,
    _find_slipping_elements,
    _node_to_element_mass_or_force,
    _elements_to_nodes_inplace,
    _node_to_element_position,
    _node_to_element_velocity,
)


class TestDotProduct:
    "class to test the dot product function"

    @pytest.mark.parametrize("ndim", [3])
    def test_dot_product_using_numpy(self, ndim):
        """
        This method was generated by "copilot" in VS code;
        This method uses numpy dot product to compare with the output of our function,
        numpy dot product uses an optimized implementation that takes advantage of
        hardware-specific optimizations such as SIMD.
        """
        vector1 = np.random.randn(ndim)
        vector2 = np.random.randn(ndim)
        dot_product = _dot_product(vector1, vector2)
        assert_allclose(dot_product, np.dot(vector1, vector2))

    def test_dot_product_with_verified_values(self):
        "Testing function with analytically verified values"

        "test for parallel vectors"
        vec1 = [1, 0, 0]
        vec2 = [2, 0, 0]
        dot_product = _dot_product(vec1, vec2)
        assert_allclose(dot_product, 2)
        """Calcutlations :  vec1 . vect2
                            [1, 0, 0] . [2, 0, 0]
                            1*2 + 0*0 + 0*0
                            2 (Answer)"""

        "test for perpendicular vectors"
        vec1 = [1, 0, 0]
        vec2 = [0, 1, 0]
        dot_product = _dot_product(vec1, vec2)
        assert_allclose(dot_product, 0)
        """Calcutlations :  vec1 . vect2
                            [1, 0, 0] . [0, 1, 0]
                            1*0 + 0*1 + 0*0
                            0 (Answer)"""

        "test for opposite vectors"
        vec1 = [1, 0, 0]
        vec2 = [-1, 0, 0]
        dot_product = _dot_product(vec1, vec2)
        assert_allclose(dot_product, -1)
        """Calcutlations :  vec1 . vect2
                            [1, 0, 0] . [-1, 0, 0]
                            1*-1 + 0*0 + 0*0
                            -1 (Answer)"""

        "test for arbitrary vectors"
        vec1 = [1, -2, 3]
        vec2 = [-2, 1, 3]
        dot_product = _dot_product(vec1, vec2)
        assert_allclose(dot_product, 5)
        """Calcutlations :  vec1 . vect2
                            [1, -2, 3] . [-2, 1, 3]
                            1*-2 + -2*1 + 3*3
                            -2 - 2 + 9
                            5 (Answer)"""


def test_norm_with_verified_values():
    "Function to test the _norm function"

    "Testing function with analytically verified values"

    "test for null vector"
    vec1 = [0, 0, 0]
    norm = _norm(vec1)
    assert_allclose(norm, 0)
    """Calcutlations :  sqrt(0^2 + 0^2 + 0^2)
                        sqrt(0 + 0 + 0)
                        0 (Answer)"""

    "test for unit vector"
    vec1 = [1, 1, 1]
    norm = _norm(vec1)
    assert_allclose(norm, 1.7320508075688772)
    """Calcutlations :  sqrt(1^2 + 1^2 + 1^2)
                        sqrt(1 + 1 + 1)
                        sqrt(3)
                        1.7320508075688772 (Answer)"""

    "test for arbitrary natural number vector"
    vec1 = [1, 2, 3]
    norm = _norm(vec1)
    assert_allclose(norm, 3.7416573867739413)
    """Calcutlations :  sqrt(1^2 + 2^2 + 3^2)
                        sqrt(1 + 4 + 9)
                        sqrt(14)
                        3.7416573867739413 (Answer)"""

    "test for decimal values vector"
    vec1 = [0.001, 0.002, 0.003]
    norm = _norm(vec1)
    assert_allclose(norm, 0.0037416573867739412)
    """Calcutlations :  sqrt(0.001^2 + 0.002^2 + 0.003^2)
                        sqrt(0.000001 + 0.000004 + 0.000009)
                        sqrt(0.000014)
                        0.0037416573867739412 (Answer)"""


@pytest.mark.parametrize(
    "x, result",
    [(0.5, 1), (1.5, 1.5), (2.5, 2)],
)
def test_clip_with_verified_values(x, result):

    "Function to test the _clip function"

    """_clip is a simple comparison function;
       The tests are made to get _clip to return 'low', 'x', 'high' in the respective order"""

    low = 1.0
    high = 2.0
    assert _clip(x, low, high) == result


@pytest.mark.parametrize(
    "x, result",
    [(0.5, 1), (1.5, 0), (2.5, 1)],
)
def test_out_of_bounds_with_verified_values(x, result):

    "Function to test the _out_of_bounds function"

    """_out_of_bounds returns 1 if x < low or x > high, else returns 0"""

    low = 1.0
    high = 2.0
    assert _out_of_bounds(x, low, high) == result


def test_find_min_dist():
    "Function to test the _find_min_dist function"

    "testing function with analytically verified values"

    "intersecting lines"
    x1 = np.array([0, 0, 0])
    e1 = np.array([1, 1, 1])
    # line 1 starts along origin and points towards (1,1,1)
    x2 = np.array([0, 1, 0])
    e2 = np.array([1, 0, 1])
    # line 2 starts along (0,1,0) and points towards (1,0,1)
    min_dist_vec, contact_point_of_system2, contact_point_of_system1 = _find_min_dist(
        x1, e1, x2, e2
    )
    assert_allclose(min_dist_vec, [0, 0, 0])
    # since the lines intersect, the minimum distance is 0.
    assert_allclose(contact_point_of_system2, [1, 1, 1])
    # the contact point of line 2 and line 1 is (1,1,1)
    assert_allclose(contact_point_of_system1, [-1, -1, -1])
    # the function returns -1 for contact point of system 1 in case of intersecting lines

    "non intersecting lines"
    x1 = np.array([0, 0, 0])
    e1 = np.array([1, 0, 0])
    # line 1 starts along origin and points towards (1,0,0)
    x2 = np.array([0, 1, 0])
    e2 = np.array([0, 0, 1])
    # line 2 starts along (0,1,0) and points towards (0,0,1)
    min_dist_vec, contact_point_of_system2, contact_point_of_system1 = _find_min_dist(
        x1, e1, x2, e2
    )
    assert_allclose(min_dist_vec, [0, 1, 0])
    # minimum distance is 1 unit(verified using GeoGebra 3D calculator visualisation)
    assert_allclose(contact_point_of_system2, [0, 1, 0])
    assert_allclose(contact_point_of_system1, [0, 0, 0])

    "parallel lines"
    x1 = np.array([0, 0, 0])
    e1 = np.array([1, 0, 0])
    # line 1 starts along origin and points towards (1,0,0)
    x2 = np.array([0, 1, 0])
    e2 = np.array([1, 1, 0])
    # line 2 starts along (0,1,0) and points towards (1,1,0)
    min_dist_vec, contact_point_of_system2, contact_point_of_system1 = _find_min_dist(
        x1, e1, x2, e2
    )
    assert_allclose(min_dist_vec, [0, 1, 0])
    # minimum distance is 1 unit(verified using GeoGebra 3D calculator visualisation)
    assert_allclose(contact_point_of_system2, [0, 1, 0])
    assert_allclose(contact_point_of_system1, [0, 0, 0])


def test_aabbs_not_intersecting():
    "Function to test the _aabb_intersecting function"

    "testing function with analytically verified values"

    " intersecting boxes"
    aabb_one = np.array([[0, 0], [0, 0], [0, 0]])
    aabb_two = np.array([[0, 0], [0, 0], [0, 0]])
    "both boxes are overlapping perfectly thus intersecting"
    assert _aabbs_not_intersecting(aabb_one, aabb_two) == 0

    " non Intersecting boxes"
    aabb_one = np.array([[0, 1], [0, 1], [0, 1]])
    "box one is a unit size cube in the first quadrant with origin as one of its vertices"
    aabb_two = np.array([[2, 3], [2, 3], [2, 3]])
    "box two is a unit size cube in the first quadrant with (2,2,2) as the closest vertex to box 1"
    assert _aabbs_not_intersecting(aabb_one, aabb_two) == 1


def mock_rod_init(self):

    "Initializing Rod"

    """
    This is a small rod with 2 elements;
    Initial Parameters:
    element's radius = 1, length = 1,
    tangent vector for both elements is (1, 0, 0),
    stationary rod i.e velocity vector of each node is (0, 0, 0),
    internal/external forces vectors are also (0, 0, 0)
    """

    self.n_elems = 2
    self.position_collection = np.array([[1, 2, 3], [0, 0, 0], [0, 0, 0]])
    self.radius = np.array([1, 1])
    self.lengths = np.array([1, 1])
    self.tangents = np.array([[1.0, 1.0], [0.0, 0.0], [0.0, 0.0]])
    self.velocity_collection = np.array(
        [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]
    )
    self.internal_forces = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])
    self.external_forces = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])


def mock_cylinder_init(self):

    "Initializing Cylinder"

    """
    This is a rigid body cylinder;,
    Initial Parameters:
    radius = 1, length = 2,
    center positioned at origin i.e (0, 0, 0),
    cylinder's upright in x,y,z plane thus the director array,
    stationary cylinder i.e velocity vector is (0, 0, 0),
    external forces and torques vectors are also (0, 0, 0)
    """

    self.n_elems = 1
    self.position = np.array([[0], [0], [0]])
    self.director = np.array(
        [[[1.0], [0.0], [0.0]], [[0.0], [1.0], [0.0]], [[0.0], [0.0], [1.0]]]
    )
    self.radius = 1.0
    self.length = 2.0
    self.velocity_collection = np.array([[0.0], [0.0], [0.0]])
    self.external_forces = np.array([[0.0], [0.0], [0.0]])
    self.external_torques = np.array([[0.0], [0.0], [0.0]])


def mock_sphere_init(self):

    "Initializing Sphere"

    """
    This is a rigid body sphere;,
    Initial Parameters:
    radius = 1,
    center positioned at origin i.e (0, 0, 0),
    sphere's upright in x,y,z plane thus the director array,
    stationary sphere i.e velocity vector is (0, 0, 0),
    external forces and torques vectors are also (0, 0, 0)
    """

    self.n_elems = 1
    self.position = np.array([[0], [0], [0]])
    self.director = np.array(
        [[[1.0], [0.0], [0.0]], [[0.0], [1.0], [0.0]], [[0.0], [0.0], [1.0]]]
    )
    self.radius = 1.0
    self.velocity_collection = np.array([[0.0], [0.0], [0.0]])
    self.external_forces = np.array([[0.0], [0.0], [0.0]])
    self.external_torques = np.array([[0.0], [0.0], [0.0]])


MockRod = type("MockRod", (RodBase,), {"__init__": mock_rod_init})

MockCylinder = type("MockCylinder", (Cylinder,), {"__init__": mock_cylinder_init})

MockSphere = type("MockSphere", (Sphere,), {"__init__": mock_sphere_init})


def test_prune_using_aabbs_rod_cylinder():
    "Function to test the prune using aabbs rod cylinder function"

    "Testing function with analytically verified values"

    "Intersecting rod and cylinder"

    """
    Since both the initialized rod and cylinder are overlapping in 3D space at (1, 1, 1);
    Hence they are intersectiong and the function should return 0
    """
    rod = MockRod()
    cylinder = MockCylinder()
    assert (
        _prune_using_aabbs_rod_cylinder(
            rod.position_collection,
            rod.radius,
            rod.lengths,
            cylinder.position,
            cylinder.director,
            cylinder.radius,
            cylinder.length,
        )
        == 0
    )

    "Non - Intersecting rod and cylinder"
    rod = MockRod()
    cylinder = MockCylinder()

    """
    Changing the position of cylinder in 3D space so the rod and cylinder don't overlap/intersect.
    """
    cylinder.position = np.array([[20], [3], [4]])
    assert (
        _prune_using_aabbs_rod_cylinder(
            rod.position_collection,
            rod.radius,
            rod.lengths,
            cylinder.position,
            cylinder.director,
            cylinder.radius,
            cylinder.length,
        )
        == 1
    )


def test_prune_using_aabbs_rod_rod():
    "Function to test the prune using aabbs rod rod function"

    "Testing function with analytically verified values"

    "Intersecting rod and rod"
    """
    Since both the rods have same position, node's radius and length, they are overlapping/intersecting in 3D space.
    """
    rod_one = MockRod()
    rod_two = MockRod()
    assert (
        _prune_using_aabbs_rod_rod(
            rod_one.position_collection,
            rod_one.radius,
            rod_one.lengths,
            rod_two.position_collection,
            rod_two.radius,
            rod_two.lengths,
        )
        == 0
    )

    "Non - Intersecting rod and rod"
    """
    Changing the position of rod_two in 3D space so the rod_one and rod_two don't overlap/intersect.
    """
    rod_two.position_collection = np.array([[20, 21, 22], [0, 0, 0], [0, 0, 0]])
    assert (
        _prune_using_aabbs_rod_rod(
            rod_one.position_collection,
            rod_one.radius,
            rod_one.lengths,
            rod_two.position_collection,
            rod_two.radius,
            rod_two.lengths,
        )
        == 1
    )


def test_prune_using_aabbs_rod_sphere():
    "Function to test the prune using aabbs rod sphere function"

    "Testing function with analytically verified values"

    "Intersecting rod and sphere"
    """
    Since both the rod and sphere are overlapping in 3D space at (1, 1, 1);
    Hence they are intersectiong and the function should return 0
    """
    rod = MockRod()
    sphere = MockSphere()
    assert (
        _prune_using_aabbs_rod_sphere(
            rod.position_collection,
            rod.radius,
            rod.lengths,
            sphere.position,
            sphere.director,
            sphere.radius,
        )
        == 0
    )

    "Non - Intersecting rod and sphere"
    rod = MockRod()
    sphere = MockSphere()

    """
    Changing the position of sphere in 3D space so the rod and sphere don't overlap/intersect.
    """
    sphere.position = np.array([[20], [3], [4]])
    assert (
        _prune_using_aabbs_rod_sphere(
            rod.position_collection,
            rod.radius,
            rod.lengths,
            sphere.position,
            sphere.director,
            sphere.radius,
        )
        == 1
    )


class TestRodPlaneAuxiliaryFunctions:
    @pytest.mark.parametrize("n_elem", [2, 3, 5, 10, 20])
    def test_linear_interpolation_slip(self, n_elem):
        velocity_threshold = 1.0

        # if slip velocity larger than threshold
        velocity_slip = np.repeat(
            np.array([0.0, 0.0, 2.0]).reshape(3, 1), n_elem, axis=1
        )
        slip_function = _find_slipping_elements(velocity_slip, velocity_threshold)
        correct_slip_function = np.zeros(n_elem)
        assert_allclose(correct_slip_function, slip_function, atol=Tolerance.atol())

        # if slip velocity smaller than threshold
        velocity_slip = np.repeat(
            np.array([0.0, 0.0, 0.0]).reshape(3, 1), n_elem, axis=1
        )
        slip_function = _find_slipping_elements(velocity_slip, velocity_threshold)
        correct_slip_function = np.ones(n_elem)
        assert_allclose(correct_slip_function, slip_function, atol=Tolerance.atol())

        # if slip velocity smaller than threshold but very close to threshold
        velocity_slip = np.repeat(
            np.array([0.0, 0.0, 1.0 - 1e-6]).reshape(3, 1), n_elem, axis=1
        )
        slip_function = _find_slipping_elements(velocity_slip, velocity_threshold)
        correct_slip_function = np.ones(n_elem)
        assert_allclose(correct_slip_function, slip_function, atol=Tolerance.atol())

        # if slip velocity larger than threshold but very close to threshold
        velocity_slip = np.repeat(
            np.array([0.0, 0.0, 1.0 + 1e-6]).reshape(3, 1), n_elem, axis=1
        )
        slip_function = _find_slipping_elements(velocity_slip, velocity_threshold)
        correct_slip_function = np.ones(n_elem) - 1e-6
        assert_allclose(correct_slip_function, slip_function, atol=Tolerance.atol())

        # if half of the array slip velocity is larger than threshold and half of it
        # smaller than threshold
        velocity_slip = np.hstack(
            (
                np.repeat(np.array([0.0, 0.0, 2.0]).reshape(3, 1), n_elem, axis=1),
                np.repeat(np.array([0.0, 0.0, 0.0]).reshape(3, 1), n_elem, axis=1),
            )
        )
        slip_function = _find_slipping_elements(velocity_slip, velocity_threshold)
        correct_slip_function = np.hstack((np.zeros(n_elem), np.ones(n_elem)))
        assert_allclose(correct_slip_function, slip_function, atol=Tolerance.atol())

    @pytest.mark.parametrize("n_elem", [2, 3, 5, 10, 20])
    def test_node_to_element_mass_or_force(self, n_elem):
        random_vector = np.random.rand(3).reshape(3, 1)
        input = np.repeat(random_vector, n_elem + 1, axis=1)
        input[..., 0] *= 0.5
        input[..., -1] *= 0.5
        correct_output = np.repeat(random_vector, n_elem, axis=1)
        output = _node_to_element_mass_or_force(input)
        assert_allclose(correct_output, output, atol=Tolerance.atol())
        assert_allclose(np.sum(input), np.sum(output), atol=Tolerance.atol())

    # These functions are used in the case if Numba is available
    class TestGeneralAuxiliaryFunctions:
        @pytest.mark.parametrize("n_elem", [2, 3, 5, 10, 20])
        def test_node_to_element_position(self, n_elem):
            """
            This function tests _node_to_element_position function. We are
            converting node positions to element positions. Here also
            we are using numba to speed up the process.

            Parameters
            ----------
            n_elem

            Returns
            -------

            """
            random = np.random.rand()  # Adding some random numbers
            input_position = random * np.ones((3, n_elem + 1))
            correct_output = random * np.ones((3, n_elem))

            output = _node_to_element_position(input_position)
            assert_allclose(correct_output, output, atol=Tolerance.atol())

        @pytest.mark.parametrize("n_elem", [2, 3, 5, 10, 20])
        def test_node_to_element_velocity(self, n_elem):
            """
            This function tests _node_to_element_velocity function. We are
            converting node velocities to element velocities. Here also
            we are using numba to speed up the process.

            Parameters
            ----------
            n_elem

            Returns
            -------

            """
            random = np.random.rand()  # Adding some random numbers
            input_velocity = random * np.ones((3, n_elem + 1))
            input_mass = 2.0 * random * np.ones(n_elem + 1)
            correct_output = random * np.ones((3, n_elem))

            output = _node_to_element_velocity(
                mass=input_mass, node_velocity_collection=input_velocity
            )
            assert_allclose(correct_output, output, atol=Tolerance.atol())

        @pytest.mark.parametrize("n_elem", [2, 3, 5, 10, 20])
        def test_elements_to_nodes_inplace(self, n_elem):
            """
            This function _elements_to_nodes_inplace. We are
            converting node velocities to element velocities. Here also
            we are using numba to speed up the process.

            Parameters
            ----------
            n_elem

            Returns
            -------

            """
            random = np.random.rand()  # Adding some random numbers
            vector_in_element_frame = random * np.ones((3, n_elem))
            vector_in_node_frame = np.zeros((3, n_elem + 1))
            correct_output = vector_in_node_frame.copy()
            correct_output[:, :n_elem] += 0.5 * vector_in_element_frame
            correct_output[:, 1 : n_elem + 1] += 0.5 * vector_in_element_frame

            _elements_to_nodes_inplace(vector_in_element_frame, vector_in_node_frame)
            assert_allclose(correct_output, vector_in_node_frame, atol=Tolerance.atol())
